def create_table_sql(query,fname,schema,table_name):
    start_time = time.time()
    # Set credential
    my_credentials = get_credentials('my_credentials.txt')

    special_characters = "!@#$%^&*()[]{};:,./<>?\|`~-=_+"

    filename = fname.split('.')
    fname_clean = filename[0].translate ({ord(c): "_" for c in special_characters})
    for i in range(1,len(filename)):
        fname_clean += '.' + filename[i]
    
    # Replace special characters in table name with "_"
    if any(item in special_characters for item in table_name):
        print('Replacing special characters in table name with "_".')
        table_name = table_name.translate ({ord(c): "_" for c in special_characters})
    
    dataset_dir = pathlib.Path(r'D:/Dataset')
    dataset_dir_list = [item for item in dataset_dir.rglob("*") if item.is_dir()]
    dataset_file_list = [item for item in dataset_dir.rglob("*") if item.is_file()]
    dataset_dir_array_shape = np.array(dataset_dir_list).shape
    dataset_file_array_shape = np.array(dataset_file_list).shape
    fullpath = None
    is_fullpath = None
    for i in range(dataset_dir_array_shape[0]):
        for j in range(dataset_file_array_shape[0]):
            if os.path.join(str(dataset_dir_list[i]),fname) == str(dataset_file_list[j]):
                folder_path = str(dataset_dir_list[i])
                fullpath = os.path.join(str(dataset_dir_list[i]),fname)
                is_fullpath = os.path.exists(fullpath)
                if table_name == '' or table_name == None:
                    name = fname.split('.')
                    filename = name[0].split('/')
                    table_name = filename[-1]
                if query == '' or query == None:
                    query = f'''
                                select * from {schema}.{table_name};
                             '''
                fname = folder_path.replace("\\","/")+'/'+fname
            elif os.path.join(str(dataset_dir_list[i]),fname_clean) == str(dataset_file_list[j]):
                folder_path = str(dataset_dir_list[i])
                fullpath = os.path.join(str(dataset_dir_list[i]),fname_clean)
                is_fullpath = os.path.exists(fullpath)
                if table_name == '' or table_name == None:
                    name = fname_clean.split('.')
                    filename = name[0].split('/')
                    table_name = filename[-1]
                if query == '' or query == None:
                    query = f'''
                                select * from {schema}.{table_name};
                             '''
                fname_clean_path = folder_path.replace("\\","/")+'/'+fname_clean
                
    # Replace special characters in file name with "_"
    if any(item in special_characters for item in fname) and os.path.isfile(fname_clean_path) == False:
        print('File name contains special characters. Renaming file.')
        old_file = pathlib.Path(os.path.join(folder_path,fname))
        new_file = pathlib.Path(os.path.join(folder_path,fname_clean))
        fname = str(old_file.rename(new_file))
        fullpath = fname
    else:
        fname = fname_clean_path
        
    if os.path.isfile(fname) == True:
        try:
            print('File already exists.')
            print('Fullpath:',fullpath)
        except:
            Err
        else:            
            # Open
            engine = connect_sqlalchemy(my_credentials)
    
            conn = engine.raw_connection()
            curr = conn.cursor()
            
            # Check if table exists in database
            print('Checking in the database.')
            try:
                curr.execute(query_check(schema,table_name))
            except ValueError as Err:
                raise Err
            else:
                if curr.fetchone()[0] >= 1:
                    df = pd.read_sql_query(query,engine)
                    df.columns = df.columns.str.upper()
                    is_new_table = input('Table already exists in the database. Do you want to create a new table? [YES/NO]')
                    if is_new_table.upper() == 'YES' or is_new_table.upper() == 'Y':
                        new_table_name = input('Insert new table name.')
                        # Replace special characters in table name with "_"
                        if any(item in special_characters for item in new_table_name):
                            print('Replacing special characters in new table name with "_".')
                            new_table_name = new_table_name.translate ({ord(c): "_" for c in special_characters})
                        new_fname = folder_path.replace("\\","/")+'/'+new_table_name+''.join(pathlib.Path(fname).suffixes)
                        try:
                            curr.execute(query_check(schema,new_table_name))
                        except ValueError as Err:
                            raise Err
                        else:
                            if curr.fetchone()[0] >= 1:
                                print('New table name already exists in the database.')
                            else:
                                print('New fullpath:',new_fname)
                                # Convert dataframe to excel and save
                                if fname.endswith('.xlsx') or fname.endswith('.xlsm') or fname.endswith('.xls'):
                                    with pd.ExcelWriter(new_fname) as writer:
                                        df.to_excel(writer, index=False)
                                elif fname.endswith('.csv'):
                                    df.to_csv(new_fname, index=False, encoding='utf-8')
                                curr.close()
                                # Convert dataframe to sql
                                print('Importing to database.')
                                sql = df.to_sql(name=new_table_name.upper(), con=engine, schema=schema, index=False)
                    else:
                        if_exists_proceed = input('Do you want to append to or replace the existing table? [YES/NO]')
                        if if_exists_proceed.upper() == 'YES' or if_exists_proceed.upper() == 'Y':
                            method = input('Choose on how to proceed: [APPEND/REPLACE]')
                            method.lower()
                            # Convert dataframe to sql
                            print('Importing to database.')
                            sql = df.to_sql(name=table_name, con=engine, schema=schema, index=False, if_exists=method)
                else:
                    if is_fullpath == True:
                        print('No existing table. Importing to database.')
                        if fname.endswith('.xlsx') or fname.endswith('.xlsm') or fname.endswith('.xls'):
                            # Read file and open as dataframe
                            df = pd.read_excel(fullpath, sheet_name=None, index_col=False)
                            sheet_names = df.keys()
                            for i in range(len(sheet_names)):
                                table_name = table_name + '_' + sheet_names[i]
                                # Convert dataframe to sql
                                sql = df.to_sql(name=table_name, con=engine, schema=schema, index=False)
                        elif fname.endswith('.csv'):
                            # Read file and open as dataframe
                            df = pd.read_csv(fullpath, index_col=False)
                            # Convert dataframe to sql
                            sql = df.to_sql(name=table_name, con=engine, schema=schema, index=False)
        
            # Close
            engine.dispose()
            print('Finished.')
    else:
        # Open
        engine = connect_sqlalchemy(my_credentials)
        conn = engine.raw_connection()
        curr = conn.cursor()
        
        df = pd.read_sql_query(query,engine)
        df.columns = df.columns.str.upper()
        
        # Convert dataframe to excel and save
        print('Creating file.')
        if fname.endswith('.xlsx') or fname.endswith('.xlsm') or fname.endswith('.xls'):
            with pd.ExcelWriter(fname) as writer:
                df.to_excel(writer, index=False)
        elif fname.endswith('.csv'):
            df.to_csv(fname, index=False, encoding='utf-8')
            
        if is_fullpath == True:
            # Read file and open as dataframe
            if fname.endswith('.xlsx') or fname.endswith('.xlsm') or fname.endswith('.xls'):
                df = pd.read_excel(fullpath, sheet_name=None, index_col=False)
                sheet_names = df.keys()
            elif fname.endswith('.csv'):
                df = pd.read_csv(fullpath, index_col=False)

        # Check if table exists in database
        print('Checking in the database.')
        try:
            curr.execute(query_check(schema,table_name))
        except ValueError as Err:
            raise Err
        else:
            if curr.fetchone()[0] >= 1:
                is_new_table = input('Table already exists in the database. Do you want to create a new table? [YES/NO]')
                if is_new_table.upper() == 'YES' or is_new_table.upper() == 'Y':
                    df = pd.read_sql_query(query,engine)
                    df.columns = df.columns.str.upper()
                    new_table_name = input('Insert new table name.')
                    # Replace special characters in table name with "_"
                    if any(item in special_characters for item in new_table_name):
                        print('Replacing special characters in new table name with "_".')
                        new_table_name = new_table_name.translate ({ord(c): "_" for c in special_characters})
                    new_fname = folder_path.replace("\\","/")+'/'+new_table_name+''.join(pathlib.Path(fname).suffixes)
                    try:
                        curr.execute(query_check(schema,new_table_name))
                    except ValueError as Err:
                        raise Err
                    else:
                        if curr.fetchone()[0] >= 1:
                            print('New table name already exists in the database.')
                        else:
                            print('New fullpath:',new_fname)
                            # Convert dataframe to excel and save
                            if new_table_name.endswith('.xlsx') or fname.endswith('.xlsm') or fname.endswith('.xls'):
                                with pd.ExcelWriter(new_fname) as writer:
                                    df.to_excel(writer, index=False)
                            elif fname.endswith('.csv'):
                                df.to_csv(new_fname, index=False, encoding='utf-8')
                            curr.close()
                            # Convert dataframe to sql
                            print('Importing to database.')
                            sql = df.to_sql(name=new_table_name.upper(), con=engine, schema=schema, index=False)
                else:
                    if_exists_proceed = input('Do you want to append to or replace the existing table? [YES/NO]')
                    if if_exists_proceed.upper() == 'YES' or if_exists_proceed.upper() == 'Y':
                        method = input('Choose on how to proceed: [APPEND/REPLACE]')
                        method.lower()
                        # Convert dataframe to sql
                        print('Importing to database.')
                        sql = df.to_sql(name=table_name, con=engine, schema=schema, index=False, if_exists=method)
            else:
                # Convert dataframe to sql
                print('No existing table. Importing to database.')
                if fname.endswith('.xlsx') or fname.endswith('.xlsm') or fname.endswith('.xls'):
                    for i in range(len(sheet_names)):
                        table_name = table_name + '_' + sheet_names[i]
                        sql = df.to_sql(name=table_name, con=engine, schema=schema, index=False)
                elif fname.endswith('.csv'):
                    sql = df.to_sql(name=table_name, con=engine, schema=schema, index=False)
    
        # Close
        engine.dispose()
        print('Finished.')
        
    end_time = time.time()
    print('Execution time: {:2f}'.format(end_time - start_time),'s')
